// Code generated by protoc-gen-gogo.
// source: sourcegraph.proto
// DO NOT EDIT!

/*
Package sourcegraph is a generated protocol buffer package.

It is generated from these files:
	sourcegraph.proto

It has these top-level messages:
	Badge
	CombinedStatus
	Counter
	ListOptions
	Readme
	Repo
	BadgeList
	CounterList
	RepoBadgesCountHitsOp
	RepoBadgesCountHitsResult
	RepoListOptions
	RepoPermissions
	RepoRevSpec
	RepoSpec
	RepoStatus
	RepoStatusesCreateOp
	RepoList
	ReposListCommitsOp
	RepoListCommitsOptions
	CommitList
	ReposListBranchesOp
	RepoListBranchesOptions
	BranchList
	ReposListTagsOp
	RepoListTagsOptions
	TagList
*/
package sourcegraph

import proto "github.com/gogo/protobuf/proto"

// discarding unused import gogoproto "gogoproto/gogo.pb"
import pbtypes "sourcegraph.com/sqs/pbtypes"
import pbtypes1 "sourcegraph.com/sqs/pbtypes"
import vcs "sourcegraph.com/sourcegraph/go-vcs/vcs"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

type Badge struct {
	Name              string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description       string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	ImageURL          string `protobuf:"bytes,3,opt,name=image_url,proto3" json:"image_url,omitempty"`
	UncountedImageURL string `protobuf:"bytes,4,opt,name=uncounted_image_url,proto3" json:"uncounted_image_url,omitempty"`
	Markdown          string `protobuf:"bytes,5,opt,name=markdown,proto3" json:"markdown,omitempty"`
}

func (m *Badge) Reset()         { *m = Badge{} }
func (m *Badge) String() string { return proto.CompactTextString(m) }
func (*Badge) ProtoMessage()    {}

// CombinedStatus is the combined status (i.e., incorporating statuses from all
// contexts) of the repository at a specific rev.
type CombinedStatus struct {
	// CommitID is the full commit ID of the commit this status describes.
	CommitID string `protobuf:"bytes,1,opt,name=commit_id,proto3" json:"commit_id,omitempty"`
	// State is the combined status of the repository. Possible values are: failture,
	// pending, or success.
	State string `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	// Statuses are the statuses for each context.
	Statuses []*RepoStatus `protobuf:"bytes,3,rep,name=statuses" json:"statuses,omitempty"`
}

func (m *CombinedStatus) Reset()         { *m = CombinedStatus{} }
func (m *CombinedStatus) String() string { return proto.CompactTextString(m) }
func (*CombinedStatus) ProtoMessage()    {}

func (m *CombinedStatus) GetStatuses() []*RepoStatus {
	if m != nil {
		return m.Statuses
	}
	return nil
}

type Counter struct {
	Name              string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description       string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	ImageURL          string `protobuf:"bytes,3,opt,name=image_url,proto3" json:"image_url,omitempty"`
	UncountedImageURL string `protobuf:"bytes,4,opt,name=uncounted_image_url,proto3" json:"uncounted_image_url,omitempty"`
	Markdown          string `protobuf:"bytes,5,opt,name=markdown,proto3" json:"markdown,omitempty"`
}

func (m *Counter) Reset()         { *m = Counter{} }
func (m *Counter) String() string { return proto.CompactTextString(m) }
func (*Counter) ProtoMessage()    {}

// ListOptions specifies general pagination options for fetching a list of results.
type ListOptions struct {
	PerPage int32 `protobuf:"varint,1,opt,name=per_page,proto3" json:"per_page,omitempty" url:",omitempty"`
	Page    int32 `protobuf:"varint,2,opt,name=page,proto3" json:"page,omitempty" url:",omitempty"`
}

func (m *ListOptions) Reset()         { *m = ListOptions{} }
func (m *ListOptions) String() string { return proto.CompactTextString(m) }
func (*ListOptions) ProtoMessage()    {}

// A Readme represents a formatted "README"-type file in a repository.
type Readme struct {
	// Path is the relative path of this readme file from the repository root.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// HTML is the formatted HTML of this readme.
	HTML string `protobuf:"bytes,2,opt,name=html,proto3" json:"html,omitempty"`
}

func (m *Readme) Reset()         { *m = Readme{} }
func (m *Readme) String() string { return proto.CompactTextString(m) }
func (*Readme) ProtoMessage()    {}

// Repo represents a source code repository.
type Repo struct {
	// URI is a normalized identifier for this repository based on its primary clone
	// URL. E.g., "github.com/user/repo".
	URI string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// Name is the base name (the final path component) of the repository, typically
	// the name of the directory that the repository would be cloned into. (For
	// example, for git://example.com/foo.git, the name is "foo".)
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Description is a brief description of the repository.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// VCS is the short name of the VCS system that this repository uses: "git" or
	// "hg".
	VCS string `protobuf:"bytes,4,opt,name=vcs,proto3" json:"vcs,omitempty"`
	// HTTPCloneURL is the HTTPS clone URL of the repository (or the HTTP clone URL, if
	// no HTTPS clone URL is available).
	HTTPCloneURL string `protobuf:"bytes,5,opt,name=http_clone_url,proto3" json:"http_clone_url,omitempty"`
	// SSHCloneURL is the SSH clone URL if the repository, if any.
	SSHCloneURL string `protobuf:"bytes,6,opt,name=ssh_clone_url,proto3" json:"ssh_clone_url,omitempty"`
	// HomepageURL is the URL to the repository's homepage, if any.
	HomepageURL string `protobuf:"bytes,7,opt,name=homepage_url,proto3" json:"homepage_url,omitempty"`
	// DefaultBranch is the default VCS branch used (typically "master" for git
	// repositories and "default" for hg repositories).
	DefaultBranch string `protobuf:"bytes,8,opt,name=default_branch,proto3" json:"default_branch,omitempty"`
	// Language is the primary programming language used in this repository.
	Language string `protobuf:"bytes,9,opt,name=language,proto3" json:"language,omitempty"`
	// Blocked is whether this repo has been blocked by an admin (and
	// will not be returned via the external API).
	Blocked bool `protobuf:"varint,10,opt,name=blocked,proto3" json:"blocked,omitempty"`
	// Deprecated repositories are labeled as such and hidden from global search
	// results.
	Deprecated bool `protobuf:"varint,11,opt,name=deprecated,proto3" json:"deprecated,omitempty"`
	// Fork is whether this repository is a fork.
	Fork bool `protobuf:"varint,12,opt,name=fork,proto3" json:"fork,omitempty"`
	// Mirror is whether this repository is a mirror.
	Mirror bool `protobuf:"varint,13,opt,name=mirror,proto3" json:"mirror,omitempty"`
	// Private is whether this repository is private.
	Private bool `protobuf:"varint,14,opt,name=private,proto3" json:"private,omitempty"`
	// CreatedAt is when this repository was created. If it represents an externally
	// hosted (e.g., GitHub) repository, the creation date is when it was created at
	// that origin.
	CreatedAt pbtypes.Timestamp `protobuf:"bytes,15,opt,name=created_at" json:"created_at"`
	// UpdatedAt is when this repository's metadata was last updated (on its origin if
	// it's an externally hosted repository).
	UpdatedAt pbtypes.Timestamp `protobuf:"bytes,16,opt,name=updated_at" json:"updated_at"`
	// PushedAt is when this repository's was last (VCS-)pushed to.
	PushedAt pbtypes.Timestamp `protobuf:"bytes,17,opt,name=pushed_at" json:"pushed_at"`
	// Permissions describes the permissions that the current user (or anonymous users,
	// if there is no current user) is granted to this repository.
	Permissions *RepoPermissions `protobuf:"bytes,18,opt,name=permissions" json:"permissions,omitempty"`
}

func (m *Repo) Reset()         { *m = Repo{} }
func (m *Repo) String() string { return proto.CompactTextString(m) }
func (*Repo) ProtoMessage()    {}

func (m *Repo) GetCreatedAt() pbtypes.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return pbtypes.Timestamp{}
}

func (m *Repo) GetUpdatedAt() pbtypes.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return pbtypes.Timestamp{}
}

func (m *Repo) GetPushedAt() pbtypes.Timestamp {
	if m != nil {
		return m.PushedAt
	}
	return pbtypes.Timestamp{}
}

func (m *Repo) GetPermissions() *RepoPermissions {
	if m != nil {
		return m.Permissions
	}
	return nil
}

type BadgeList struct {
	Badges []*Badge `protobuf:"bytes,1,rep,name=badges" json:"badges,omitempty"`
}

func (m *BadgeList) Reset()         { *m = BadgeList{} }
func (m *BadgeList) String() string { return proto.CompactTextString(m) }
func (*BadgeList) ProtoMessage()    {}

func (m *BadgeList) GetBadges() []*Badge {
	if m != nil {
		return m.Badges
	}
	return nil
}

type CounterList struct {
	Counters []*Counter `protobuf:"bytes,1,rep,name=counters" json:"counters,omitempty"`
}

func (m *CounterList) Reset()         { *m = CounterList{} }
func (m *CounterList) String() string { return proto.CompactTextString(m) }
func (*CounterList) ProtoMessage()    {}

func (m *CounterList) GetCounters() []*Counter {
	if m != nil {
		return m.Counters
	}
	return nil
}

type RepoBadgesCountHitsOp struct {
	Repo  RepoSpec           `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	Since *pbtypes.Timestamp `protobuf:"bytes,2,opt,name=since" json:"since,omitempty"`
}

func (m *RepoBadgesCountHitsOp) Reset()         { *m = RepoBadgesCountHitsOp{} }
func (m *RepoBadgesCountHitsOp) String() string { return proto.CompactTextString(m) }
func (*RepoBadgesCountHitsOp) ProtoMessage()    {}

func (m *RepoBadgesCountHitsOp) GetRepo() RepoSpec {
	if m != nil {
		return m.Repo
	}
	return RepoSpec{}
}

func (m *RepoBadgesCountHitsOp) GetSince() *pbtypes.Timestamp {
	if m != nil {
		return m.Since
	}
	return nil
}

type RepoBadgesCountHitsResult struct {
	Hits int32 `protobuf:"varint,1,opt,name=hits,proto3" json:"hits,omitempty"`
}

func (m *RepoBadgesCountHitsResult) Reset()         { *m = RepoBadgesCountHitsResult{} }
func (m *RepoBadgesCountHitsResult) String() string { return proto.CompactTextString(m) }
func (*RepoBadgesCountHitsResult) ProtoMessage()    {}

type RepoListOptions struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" url:",omitempty"`
	// Specifies a search query for repositories. If specified, then the Sort and
	// Direction options are ignored
	Query       string   `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty" url:",omitempty"`
	URIs        []string `protobuf:"bytes,3,rep,name=uri_s" json:"uri_s,omitempty" url:",comma,omitempty"`
	BuiltOnly   bool     `protobuf:"varint,4,opt,name=built_only,proto3" json:"built_only,omitempty" url:",omitempty"`
	Sort        string   `protobuf:"bytes,5,opt,name=sort,proto3" json:"sort,omitempty" url:",omitempty"`
	Direction   string   `protobuf:"bytes,6,opt,name=direction,proto3" json:"direction,omitempty" url:",omitempty"`
	NoFork      bool     `protobuf:"varint,7,opt,name=no_fork,proto3" json:"no_fork,omitempty" url:",omitempty"`
	Type        string   `protobuf:"bytes,8,opt,name=type,proto3" json:"type,omitempty" url:",omitempty"`
	State       string   `protobuf:"bytes,9,opt,name=state,proto3" json:"state,omitempty" url:",omitempty"`
	Owner       string   `protobuf:"bytes,10,opt,name=owner,proto3" json:"owner,omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,11,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *RepoListOptions) Reset()         { *m = RepoListOptions{} }
func (m *RepoListOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListOptions) ProtoMessage()    {}

// RepoPermissions describes the possible permissions that a user (or an anonymous
// user) can be granted to a repository.
type RepoPermissions struct {
	Read  bool `protobuf:"varint,1,opt,name=read,proto3" json:"read,omitempty"`
	Write bool `protobuf:"varint,2,opt,name=write,proto3" json:"write,omitempty"`
	Admin bool `protobuf:"varint,3,opt,name=admin,proto3" json:"admin,omitempty"`
}

func (m *RepoPermissions) Reset()         { *m = RepoPermissions{} }
func (m *RepoPermissions) String() string { return proto.CompactTextString(m) }
func (*RepoPermissions) ProtoMessage()    {}

// RepoRevSpec specifies a repository at a specific commit (or revision specifier,
// such as a branch, which is resolved on the server side to a specific commit).
//
// Filling in CommitID is an optional optimization. It avoids the need for another
// resolution of Rev. If CommitID is filled in, the "Rev" route variable becomes
// "Rev===CommitID" (e.g., "master===af4cd6"). Handlers can parse this string to
// retrieve the pre-resolved commit ID (e.g., "af4cd6") and still return data that
// constructs URLs using the unresolved revspec (e.g., "master").
//
// Why is it important/useful to pass the resolved commit ID instead of just using
// a revspec everywhere? Consider this case. Your application wants to make a bunch
// of requests for resources relating to "master"; for example, it wants to
// retrieve a source file foo.go at master and all of the definitions and
// references contained in the file. This may consist of dozens of API calls. If
// each API call specified just "master", there would be 2 problems: (1) each API
// call would have to re-resolve "master" to its actual commit ID, which takes a
// lot of extra work; and (2) if the "master" ref changed during the API calls (if
// someone pushed in the middle of the API call, for example), then your
// application would receive data from 2 different commits. The solution is for
// your application to resolve the revspec once and pass both the original revspec
// and the resolved commit ID in all API calls it makes.
//
// And why do we want to preserve the unresolved revspec? In this case, your app
// wants to let the user continue browsing "master". If the API data all referred
// to a specific commit ID, then the user would cease browsing master the next time
// she clicked a link on your app. Preserving the revspec gives the user a choice
// whether to use the absolute commit ID or the revspec (similar to how GitHub lets
// you canonicalize a URL with 'y' but does not default to using the canonical
// URL).
type RepoRevSpec struct {
	RepoSpec `protobuf:"bytes,1,opt,name=repo_spec,embedded=repo_spec" json:"repo_spec"`
	Rev      string `protobuf:"bytes,2,opt,name=rev,proto3" json:"rev,omitempty"`
	CommitID string `protobuf:"bytes,3,opt,name=commit_id,proto3" json:"commit_id,omitempty"`
}

func (m *RepoRevSpec) Reset()         { *m = RepoRevSpec{} }
func (m *RepoRevSpec) String() string { return proto.CompactTextString(m) }
func (*RepoRevSpec) ProtoMessage()    {}

// RepoSpec specifies a repository.
type RepoSpec struct {
	URI string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
}

func (m *RepoSpec) Reset()         { *m = RepoSpec{} }
func (m *RepoSpec) String() string { return proto.CompactTextString(m) }
func (*RepoSpec) ProtoMessage()    {}

// RepoStatus is the status of the repository at a specific rev (in a single
// context).
type RepoStatus struct {
	// CommitID is the full commit ID of the commit this status describes.
	CommitID string `protobuf:"bytes,1,opt,name=commit_id,proto3" json:"commit_id,omitempty"`
	// State is the current status of the repository. Possible values are: pending,
	// success, error, or failure.
	State string `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	// TargetURL is the URL of the page representing this status. It will be linked
	// from the UI to allow users to see the source of the status.
	TargetURL string `protobuf:"bytes,3,opt,name=target_url,proto3" json:"target_url,omitempty"`
	// Description is a short, high-level summary of the status.
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// A string label to differentiate this status from the statuses of other systems.
	Context   string            `protobuf:"bytes,5,opt,name=context,proto3" json:"context,omitempty"`
	CreatedAt pbtypes.Timestamp `protobuf:"bytes,6,opt,name=created_at" json:"created_at"`
	UpdatedAt pbtypes.Timestamp `protobuf:"bytes,7,opt,name=updated_at" json:"updated_at"`
}

func (m *RepoStatus) Reset()         { *m = RepoStatus{} }
func (m *RepoStatus) String() string { return proto.CompactTextString(m) }
func (*RepoStatus) ProtoMessage()    {}

func (m *RepoStatus) GetCreatedAt() pbtypes.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return pbtypes.Timestamp{}
}

func (m *RepoStatus) GetUpdatedAt() pbtypes.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return pbtypes.Timestamp{}
}

type RepoStatusesCreateOp struct {
	Repo   RepoRevSpec `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	Status RepoStatus  `protobuf:"bytes,2,opt,name=status" json:"status"`
}

func (m *RepoStatusesCreateOp) Reset()         { *m = RepoStatusesCreateOp{} }
func (m *RepoStatusesCreateOp) String() string { return proto.CompactTextString(m) }
func (*RepoStatusesCreateOp) ProtoMessage()    {}

func (m *RepoStatusesCreateOp) GetRepo() RepoRevSpec {
	if m != nil {
		return m.Repo
	}
	return RepoRevSpec{}
}

func (m *RepoStatusesCreateOp) GetStatus() RepoStatus {
	if m != nil {
		return m.Status
	}
	return RepoStatus{}
}

type RepoList struct {
	Repos []*Repo `protobuf:"bytes,1,rep,name=repos" json:"repos,omitempty"`
}

func (m *RepoList) Reset()         { *m = RepoList{} }
func (m *RepoList) String() string { return proto.CompactTextString(m) }
func (*RepoList) ProtoMessage()    {}

func (m *RepoList) GetRepos() []*Repo {
	if m != nil {
		return m.Repos
	}
	return nil
}

type ReposListCommitsOp struct {
	Repo RepoSpec                `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	Opt  *RepoListCommitsOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *ReposListCommitsOp) Reset()         { *m = ReposListCommitsOp{} }
func (m *ReposListCommitsOp) String() string { return proto.CompactTextString(m) }
func (*ReposListCommitsOp) ProtoMessage()    {}

func (m *ReposListCommitsOp) GetRepo() RepoSpec {
	if m != nil {
		return m.Repo
	}
	return RepoSpec{}
}

func (m *ReposListCommitsOp) GetOpt() *RepoListCommitsOptions {
	if m != nil {
		return m.Opt
	}
	return nil
}

type RepoListCommitsOptions struct {
	Head        string `protobuf:"bytes,1,opt,name=head,proto3" json:"head,omitempty"`
	Base        string `protobuf:"bytes,2,opt,name=base,proto3" json:"base,omitempty"`
	ListOptions `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *RepoListCommitsOptions) Reset()         { *m = RepoListCommitsOptions{} }
func (m *RepoListCommitsOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListCommitsOptions) ProtoMessage()    {}

type CommitList struct {
	Commits []*vcs.Commit `protobuf:"bytes,1,rep,name=commits" json:"commits,omitempty"`
}

func (m *CommitList) Reset()         { *m = CommitList{} }
func (m *CommitList) String() string { return proto.CompactTextString(m) }
func (*CommitList) ProtoMessage()    {}

func (m *CommitList) GetCommits() []*vcs.Commit {
	if m != nil {
		return m.Commits
	}
	return nil
}

type ReposListBranchesOp struct {
	Repo RepoSpec                 `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	Opt  *RepoListBranchesOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *ReposListBranchesOp) Reset()         { *m = ReposListBranchesOp{} }
func (m *ReposListBranchesOp) String() string { return proto.CompactTextString(m) }
func (*ReposListBranchesOp) ProtoMessage()    {}

func (m *ReposListBranchesOp) GetRepo() RepoSpec {
	if m != nil {
		return m.Repo
	}
	return RepoSpec{}
}

func (m *ReposListBranchesOp) GetOpt() *RepoListBranchesOptions {
	if m != nil {
		return m.Opt
	}
	return nil
}

type RepoListBranchesOptions struct {
	ListOptions `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *RepoListBranchesOptions) Reset()         { *m = RepoListBranchesOptions{} }
func (m *RepoListBranchesOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListBranchesOptions) ProtoMessage()    {}

type BranchList struct {
	Branches []*vcs.Branch `protobuf:"bytes,1,rep,name=branches" json:"branches,omitempty"`
}

func (m *BranchList) Reset()         { *m = BranchList{} }
func (m *BranchList) String() string { return proto.CompactTextString(m) }
func (*BranchList) ProtoMessage()    {}

func (m *BranchList) GetBranches() []*vcs.Branch {
	if m != nil {
		return m.Branches
	}
	return nil
}

type ReposListTagsOp struct {
	Repo RepoSpec             `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	Opt  *RepoListTagsOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *ReposListTagsOp) Reset()         { *m = ReposListTagsOp{} }
func (m *ReposListTagsOp) String() string { return proto.CompactTextString(m) }
func (*ReposListTagsOp) ProtoMessage()    {}

func (m *ReposListTagsOp) GetRepo() RepoSpec {
	if m != nil {
		return m.Repo
	}
	return RepoSpec{}
}

func (m *ReposListTagsOp) GetOpt() *RepoListTagsOptions {
	if m != nil {
		return m.Opt
	}
	return nil
}

type RepoListTagsOptions struct {
	ListOptions `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *RepoListTagsOptions) Reset()         { *m = RepoListTagsOptions{} }
func (m *RepoListTagsOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListTagsOptions) ProtoMessage()    {}

type TagList struct {
	Tags []*vcs.Tag `protobuf:"bytes,1,rep,name=tags" json:"tags,omitempty"`
}

func (m *TagList) Reset()         { *m = TagList{} }
func (m *TagList) String() string { return proto.CompactTextString(m) }
func (*TagList) ProtoMessage()    {}

func (m *TagList) GetTags() []*vcs.Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func init() {
}

// Client API for RepoBadges service

type RepoBadgesClient interface {
	// ListBadges lists the available badges for repo.
	ListBadges(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*BadgeList, error)
	// ListCounters lists the available counters for repo.
	ListCounters(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*CounterList, error)
	// RecordHit records a visit to a repo (that will be reflected in
	// its counter).
	RecordHit(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// CountHits returns the hit count (optionally in a recent time
	// period).
	CountHits(ctx context.Context, in *RepoBadgesCountHitsOp, opts ...grpc.CallOption) (*RepoBadgesCountHitsResult, error)
}

type repoBadgesClient struct {
	cc *grpc.ClientConn
}

func NewRepoBadgesClient(cc *grpc.ClientConn) RepoBadgesClient {
	return &repoBadgesClient{cc}
}

func (c *repoBadgesClient) ListBadges(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*BadgeList, error) {
	out := new(BadgeList)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoBadges/ListBadges", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoBadgesClient) ListCounters(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*CounterList, error) {
	out := new(CounterList)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoBadges/ListCounters", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoBadgesClient) RecordHit(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoBadges/RecordHit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoBadgesClient) CountHits(ctx context.Context, in *RepoBadgesCountHitsOp, opts ...grpc.CallOption) (*RepoBadgesCountHitsResult, error) {
	out := new(RepoBadgesCountHitsResult)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoBadges/CountHits", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RepoBadges service

type RepoBadgesServer interface {
	// ListBadges lists the available badges for repo.
	ListBadges(context.Context, *RepoSpec) (*BadgeList, error)
	// ListCounters lists the available counters for repo.
	ListCounters(context.Context, *RepoSpec) (*CounterList, error)
	// RecordHit records a visit to a repo (that will be reflected in
	// its counter).
	RecordHit(context.Context, *RepoSpec) (*pbtypes1.Void, error)
	// CountHits returns the hit count (optionally in a recent time
	// period).
	CountHits(context.Context, *RepoBadgesCountHitsOp) (*RepoBadgesCountHitsResult, error)
}

func RegisterRepoBadgesServer(s *grpc.Server, srv RepoBadgesServer) {
	s.RegisterService(&_RepoBadges_serviceDesc, srv)
}

func _RepoBadges_ListBadges_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoBadgesServer).ListBadges(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoBadges_ListCounters_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoBadgesServer).ListCounters(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoBadges_RecordHit_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoBadgesServer).RecordHit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoBadges_CountHits_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(RepoBadgesCountHitsOp)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoBadgesServer).CountHits(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RepoBadges_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RepoBadges",
	HandlerType: (*RepoBadgesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListBadges",
			Handler:    _RepoBadges_ListBadges_Handler,
		},
		{
			MethodName: "ListCounters",
			Handler:    _RepoBadges_ListCounters_Handler,
		},
		{
			MethodName: "RecordHit",
			Handler:    _RepoBadges_RecordHit_Handler,
		},
		{
			MethodName: "CountHits",
			Handler:    _RepoBadges_CountHits_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for RepoStatuses service

type RepoStatusesClient interface {
	// Create creates a repository status for the given commit.
	Create(ctx context.Context, in *RepoStatusesCreateOp, opts ...grpc.CallOption) (*RepoStatus, error)
	// GetCombined fetches the combined repository status for the given commit.
	GetCombined(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*CombinedStatus, error)
}

type repoStatusesClient struct {
	cc *grpc.ClientConn
}

func NewRepoStatusesClient(cc *grpc.ClientConn) RepoStatusesClient {
	return &repoStatusesClient{cc}
}

func (c *repoStatusesClient) Create(ctx context.Context, in *RepoStatusesCreateOp, opts ...grpc.CallOption) (*RepoStatus, error) {
	out := new(RepoStatus)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoStatuses/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoStatusesClient) GetCombined(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*CombinedStatus, error) {
	out := new(CombinedStatus)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoStatuses/GetCombined", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RepoStatuses service

type RepoStatusesServer interface {
	// Create creates a repository status for the given commit.
	Create(context.Context, *RepoStatusesCreateOp) (*RepoStatus, error)
	// GetCombined fetches the combined repository status for the given commit.
	GetCombined(context.Context, *RepoRevSpec) (*CombinedStatus, error)
}

func RegisterRepoStatusesServer(s *grpc.Server, srv RepoStatusesServer) {
	s.RegisterService(&_RepoStatuses_serviceDesc, srv)
}

func _RepoStatuses_Create_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(RepoStatusesCreateOp)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoStatusesServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoStatuses_GetCombined_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoStatusesServer).GetCombined(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RepoStatuses_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RepoStatuses",
	HandlerType: (*RepoStatusesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _RepoStatuses_Create_Handler,
		},
		{
			MethodName: "GetCombined",
			Handler:    _RepoStatuses_GetCombined_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Repos service

type ReposClient interface {
	// Get fetches a repository.
	Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*Repo, error)
	// List repositories.
	List(ctx context.Context, in *RepoListOptions, opts ...grpc.CallOption) (*RepoList, error)
	// GetReadme fetches the formatted README file for a repository.
	GetReadme(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*Readme, error)
	// Enable enables the specified repository.
	Enable(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Disable disables the specified repository.
	Disable(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// TODO(sqs!nodb-ctx): move these to a "VCS" service (not Repos)
	GetCommit(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*vcs.Commit, error)
	ListCommits(ctx context.Context, in *ReposListCommitsOp, opts ...grpc.CallOption) (*CommitList, error)
	ListBranches(ctx context.Context, in *ReposListBranchesOp, opts ...grpc.CallOption) (*BranchList, error)
	ListTags(ctx context.Context, in *ReposListTagsOp, opts ...grpc.CallOption) (*TagList, error)
}

type reposClient struct {
	cc *grpc.ClientConn
}

func NewReposClient(cc *grpc.ClientConn) ReposClient {
	return &reposClient{cc}
}

func (c *reposClient) Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) List(ctx context.Context, in *RepoListOptions, opts ...grpc.CallOption) (*RepoList, error) {
	out := new(RepoList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetReadme(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*Readme, error) {
	out := new(Readme)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetReadme", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Enable(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Enable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Disable(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Disable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetCommit(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*vcs.Commit, error) {
	out := new(vcs.Commit)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetCommit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListCommits(ctx context.Context, in *ReposListCommitsOp, opts ...grpc.CallOption) (*CommitList, error) {
	out := new(CommitList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListCommits", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListBranches(ctx context.Context, in *ReposListBranchesOp, opts ...grpc.CallOption) (*BranchList, error) {
	out := new(BranchList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListBranches", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListTags(ctx context.Context, in *ReposListTagsOp, opts ...grpc.CallOption) (*TagList, error) {
	out := new(TagList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListTags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Repos service

type ReposServer interface {
	// Get fetches a repository.
	Get(context.Context, *RepoSpec) (*Repo, error)
	// List repositories.
	List(context.Context, *RepoListOptions) (*RepoList, error)
	// GetReadme fetches the formatted README file for a repository.
	GetReadme(context.Context, *RepoRevSpec) (*Readme, error)
	// Enable enables the specified repository.
	Enable(context.Context, *RepoSpec) (*pbtypes1.Void, error)
	// Disable disables the specified repository.
	Disable(context.Context, *RepoSpec) (*pbtypes1.Void, error)
	// TODO(sqs!nodb-ctx): move these to a "VCS" service (not Repos)
	GetCommit(context.Context, *RepoRevSpec) (*vcs.Commit, error)
	ListCommits(context.Context, *ReposListCommitsOp) (*CommitList, error)
	ListBranches(context.Context, *ReposListBranchesOp) (*BranchList, error)
	ListTags(context.Context, *ReposListTagsOp) (*TagList, error)
}

func RegisterReposServer(s *grpc.Server, srv ReposServer) {
	s.RegisterService(&_Repos_serviceDesc, srv)
}

func _Repos_Get_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_List_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(RepoListOptions)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetReadme_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetReadme(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Enable_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Enable(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Disable_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Disable(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetCommit_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetCommit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListCommits_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(ReposListCommitsOp)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListCommits(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListBranches_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(ReposListBranchesOp)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListBranches(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListTags_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(ReposListTagsOp)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListTags(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Repos_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Repos",
	HandlerType: (*ReposServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Repos_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Repos_List_Handler,
		},
		{
			MethodName: "GetReadme",
			Handler:    _Repos_GetReadme_Handler,
		},
		{
			MethodName: "Enable",
			Handler:    _Repos_Enable_Handler,
		},
		{
			MethodName: "Disable",
			Handler:    _Repos_Disable_Handler,
		},
		{
			MethodName: "GetCommit",
			Handler:    _Repos_GetCommit_Handler,
		},
		{
			MethodName: "ListCommits",
			Handler:    _Repos_ListCommits_Handler,
		},
		{
			MethodName: "ListBranches",
			Handler:    _Repos_ListBranches_Handler,
		},
		{
			MethodName: "ListTags",
			Handler:    _Repos_ListTags_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for MirrorRepos service

type MirrorReposClient interface {
	// Refresh fetches the newest VCS data from the repo's origin.
	RefreshVCS(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type mirrorReposClient struct {
	cc *grpc.ClientConn
}

func NewMirrorReposClient(cc *grpc.ClientConn) MirrorReposClient {
	return &mirrorReposClient{cc}
}

func (c *mirrorReposClient) RefreshVCS(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.MirrorRepos/RefreshVCS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MirrorRepos service

type MirrorReposServer interface {
	// Refresh fetches the newest VCS data from the repo's origin.
	RefreshVCS(context.Context, *RepoSpec) (*pbtypes1.Void, error)
}

func RegisterMirrorReposServer(s *grpc.Server, srv MirrorReposServer) {
	s.RegisterService(&_MirrorRepos_serviceDesc, srv)
}

func _MirrorRepos_RefreshVCS_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(MirrorReposServer).RefreshVCS(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _MirrorRepos_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.MirrorRepos",
	HandlerType: (*MirrorReposServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RefreshVCS",
			Handler:    _MirrorRepos_RefreshVCS_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
